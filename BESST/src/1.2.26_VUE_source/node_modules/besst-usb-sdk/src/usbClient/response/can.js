/**
 * USB Client Response - CAN
 * @module response/can
 */

const eventsHandler = require('../eventsHandler');
const device = require('../device');
const requestCan = require('../request/can');
const common = require('../common');
const parsers = require('../parsers');
const logger = require('../logger');
const requestHandler = require('../request/handler');
const handler = require('./handler');
const events = eventsHandler.events;
const nestedError = require('nested-error-stacks');

/**
 * Process a CAN request object
 * @function
 * @param {Object} requestObj - request object
 */
module.exports.get = (requestObj) => {
    let usbCommand = requestObj.usbCommand;
    let source = requestObj.source;
    let target = requestObj.target;
    let can = requestObj.can;
    let code = requestObj.code;
    let subCode = requestObj.subCode;
    let data = requestObj.payload;
    let deferred = requestObj.deferred;
    let response = requestObj.response;

    try {
        if (device.isConnected()) {
            const cmdHexString = common.buildHexStringCommand(source, target, can, code, subCode);
            const requestData = parsers.request(common.HEADER, usbCommand, common.HEADER_INDEX, cmdHexString, data);
            const req = {
                code: code,
                subCode: subCode,
                source: common.stringOfEnum(common.DEVICE, parseInt(source, 16)),
                sourceCode: parseInt(source, 16),
                target: common.stringOfEnum(common.DEVICE, parseInt(target, 16)),
                targetCode: parseInt(target, 16),
                can: common.stringOfEnum(common.CAN, parseInt(can, 16)),
                canCode: parseInt(can, 16),
                payload: data
            };

            //clear all event listeners first so that we do not have additional listeners
            events.removeAllListeners('data');

            device.getDevice().write(requestData);
            //read response

            if (requestObj.doNotWait) {
                handler.successResponse(deferred, response);
            } else {
                //Timeout requests after 1 seconds
                let timer = setTimeout(() => {
                    requestHandler.removeFirstRequest();
                    if (requestHandler.getNextRequest()) {
                        events.emit('requestProcess');
                    }
                    deferred.reject('Timeout');
                }, common.timeout.CAN);

                events.on('data', packet => {
                    if (common.stringOfEnum(common.DEVICE, packet.targetCode) === req.source && common.stringOfEnum(common.DEVICE, packet.sourceCode) === req.target) {
                        switch (packet.canCode) {
                            case common.CAN.LONG_START_CMD:
                                // long data start check code and subcode and store the data
                                if (req.code === packet.code && req.subCode === packet.subCode) {
                                    //parse data length
                                    //revert the data than convert to int
                                    let len = common.hexReverse(packet.data);
                                    response.dataLen = parseInt(len, 16);
                                    response.code = packet.code;
                                    response.subCode = packet.subCode;
                                    response.target = packet.target;
                                    response.targetCode = packet.targetCode;
                                    response.source = packet.source;
                                    response.sourceCode = packet.sourceCode;
                                    response.can = packet.can;
                                    response.canCode = packet.canCode;
                                    
                                }
                                clearTimeout(timer);
                                requestCan.get(common.USB_CMD.USB_CMD_PC_TO_CAN, req.sourceCode, req.targetCode, common.CAN.NORMAL_ACK, req.code, req.subCode, '', deferred, true, false, response);
                                handler.successResponse(null, response); //do not resolve promise, chain onto next request
                                break;
                            case common.CAN.LONG_TRANG_CMD:
                                //reading data
                                clearTimeout(timer);
                                response.dataPacks[parseInt(packet.code + '' + packet.subCode, 16)] = packet;
                                requestCan.get(common.USB_CMD.USB_CMD_PC_TO_CAN, req.sourceCode, req.targetCode, common.CAN.NORMAL_ACK, req.code, req.subCode, '', deferred, true, false, response);
                                handler.successResponse(null, response); //do not resolve promise, chain onto next request
                                break;
                            case common.CAN.LONG_END_CMD:
                                response.dataPacks[parseInt(packet.code + '' + packet.subCode, 16)] = packet;
                                clearTimeout(timer);
                                requestCan.get(common.USB_CMD.USB_CMD_PC_TO_CAN, req.sourceCode, req.targetCode, common.CAN.NORMAL_ACK, req.code, req.subCode, '', deferred, true, true, response);
                                handler.successResponse(deferred, response);
                                break;
                            case common.CAN.LONG_WARNING_CMD:
                                break;
                            case common.CAN.ERROR_ACK:
                                break;
                            case common.CAN.NORMAL_ACK:
                                if(!response){
                                    response = {}
                                    let len = common.hexReverse(packet.data);
                                    response.dataLen = parseInt(len, 16);
                                    response.target = packet.target;
                                    response.targetCode = packet.targetCode;
                                    response.source = packet.source;
                                    response.sourceCode = packet.sourceCode;
                                    response.dataPacks=[];
                                }
                                response.code = packet.code;
                                response.subCode = packet.subCode;
                                response.data = packet.data;
                                response.can = packet.can;
                                response.canCode = packet.canCode;
                                clearTimeout(timer);
                                handler.successResponse(deferred, response);
                                break;
                            default:
                                break;
                        }
                    }
                });
            }
        } else {
            throw new nestedError('Unable to find ' + common.deviceName);
        }
    } catch (err) {
        deferred.reject(err);

        requestHandler.removeFirstRequest();
        if (requestHandler.getNextRequest()) {
            events.emit('requestProcess');
        }
    }
}


//////////////////
// WEBPACK FOOTER
// ./node_modules/besst-usb-sdk/src/usbClient/response/can.js
// module id = 1069
// module chunks = 73