/**
 * USB Client Request - Firmware update
 * @module request/firmware-update
 */

const q = require('q');
const crc = require('crc');
const async = require('async');
const handler = require('./handler');
const eventsHandler = require('../eventsHandler');
const events = eventsHandler.events;
const nestedError = require('nested-error-stacks');
const device = require('../device');

/**
 * Uploads a series of firmware data packs
 * @function
 * @param {string} packs - upload data packs
 * @param {string} total - total number of data packs to upload
 * @return {string} promise
 */
function uploadPacks(packs, total) {
    let deferred = q.defer();
    let counter = 0;
    async.eachOfLimit(packs, 1, (pack, index, callback) => {
        handler.request({
            buffer: pack
        }).then(res => {
            if (res.data === 1) {
                if (counter >= 20 || index >= total) { //Dont spam events
                    counter = 0;

                    /**
                     * Update progress for firmware update
                     * @event firmware-update-progress
                     * @returns {number} total - total number of packets to send
                     * @returns {number} upload - current packet index
                     */
                    events.emit('firmware-update-progress', {
                        total: total,
                        upload: index + 1
                    })
                } else {
                    counter++;
                }
                callback();

            } else {
                return callback(new nestedError('Failed to upload part'));
            }
        }).catch(err => {
            return callback(new nestedError('Failed to upload part', err));
        });
    }, (err) => {
        if (err) {
            deferred.reject(err);
        } else {
            /**
             * Update progress for firmware update
             * @event firmware-update-progress
             * @returns {number} total - total number of packets to send
             * @returns {number} upload - current packet index
             */
            events.emit('firmware-update-progress', {
                total: total,
                upload: total
            });
            handler.request({
                deferred: deferred
                }, true)
                .then(res => {
                    if (res.hexCode === 0x26) {
                        deferred.resolve(res);
                    }
                })
        }
    })
    return deferred.promise;
}

/**
 * Update the firmware on USB
 * @function
 * @param {Buffer} buffer - buffer array containing all the packs of data to send
 * @param {Object} options - allow for reconnectedWait and rebootWait configuration
 * @return {string} promise
 */
module.exports.update = (buffer, options) => {
    if (options == null || options == undefined) {
        options = {}
    }

    if (!options.reconnectedWait) {
        options.reconnectedWait = 1000;
    }
    if (!options.rebootWait) {
        options.rebootWait = 2000;
    }

    if (!buffer || buffer.length === 0) {
        return q.reject(new nestedError('empty payload'));
    } else {
        let deferred = q.defer();
        buffer = Buffer.from(buffer);
        let fileInfo = buffer.slice(0, 16);
        let fileInfo2 = buffer.slice(16, 32);
        let isBesstAppfirmware = parseInt(fileInfo.slice(2, 3).toString('hex'), 16) === 0xfc;

        let fileContentBuffer = buffer.slice(16);
        let fileCrc = crc.crc16xmodem(fileContentBuffer).toString(16);
        fileCrc = ('0000' + fileCrc).substr(-4);

        let contentLen = fileContentBuffer.length;
        const packs = [];
        //file info

        let lenHex = ('00000000' + contentLen.toString(16)).substr(-8);
        let lenBuf = Buffer.from(lenHex, 'hex');
        let arr = [0, 0, 0, 0];

        for (let j = 0; j < lenBuf.length; j++) {
            arr[arr.length - 1 - j] = lenBuf[lenBuf.length - 1 - j];
        }

        // let fst = false;
        // for(let i=4; i<16; i++ ){
        //     if(fileInfo[i]!== 0){
        //         fst = true;
        //     }
        // }
        let sec = false;
        for(let i=2; i<16; i++ ){
            if(fileInfo2[i]!== 0){
                sec = true;
            }
        }
        let dataBuf = [];
        let headData = '';

        if( fileInfo[2]>128 && fileInfo[2]<150 && !sec){
            let fileContentBuffer_32 = buffer.slice(32);
            let fileCrc_32 = crc.crc16xmodem(fileContentBuffer_32).toString(16);
            fileCrc_32 = ('0000' + fileCrc_32).substr(-4);
            let bufferCrc = Buffer.from(fileInfo2.slice(0, 2)).toString('hex')

            console.log('file',fileCrc_32,'Buffer', bufferCrc);

            if(fileCrc_32 === bufferCrc){
                headData = "0029000009" + Buffer.from(arr).toString('hex') + fileCrc;
                dataBuf = Buffer.concat([Buffer.from(headData, 'hex'), fileInfo.slice(0, 5)], 65);
            }else{
                headData = "0024000009" + Buffer.from(arr).toString('hex') + fileCrc;
                dataBuf = Buffer.concat([Buffer.from(headData, 'hex'), fileInfo.slice(0, 3)], 65);
            }
        }else{
            headData = "0024000009" + Buffer.from(arr).toString('hex') + fileCrc;
            dataBuf = Buffer.concat([Buffer.from(headData, 'hex'), fileInfo.slice(0, 3)], 65);
        }

        packs.push(dataBuf);
        let packSize = Math.ceil(contentLen / 60);
        for (let i = 0; i < packSize; i++) {
            let start = i * 60;
            let end;
            if (contentLen - start <= 60) {
                end = contentLen;
            } else {
                end = (i + 1) * 60;
            }
            let buf = fileContentBuffer.slice(start, end);
            let seqchrL = Buffer.from([i & 0xFF]);
            let seqchrH = Buffer.from([(i >> 8) & 0xFF]);
            let packetBuf = Buffer.concat([Buffer.from([0x00, 0x23]), seqchrH, seqchrL, Buffer.from([buf.length]), buf], 65);
            packs.push(packetBuf);
        }
        let total = packs.length;

        // if the firmware is for besst box will send the first request. besst box will rebot to DFU and the pid changed to 0614. than reconnected ans send the data as common upgrade buffer data
        console.log("DFU Model:" + device.dfuEnabled());
        let delayForSendPack = 0;
        if (isBesstAppfirmware && device.dfuEnabled() === false) {
            // upgrade the besst firmware
            let pack = Buffer.concat([Buffer.from('0025', 'hex')], 65);
            handler.request({
                buffer: pack
            });
            delayForSendPack = options.rebootWait + options.reconnectedWait;
            setTimeout(() => {
                device.connect();
            }, options.rebootWait)

        } else {
            delayForSendPack = 500;
        }

        setTimeout(function () {
            uploadPacks(packs, total).then(res => {
                deferred.resolve(res);
            }).catch(err => {
                deferred.reject(err);
            })
        }, delayForSendPack)

        return deferred.promise;
    }
}


//////////////////
// WEBPACK FOOTER
// ./node_modules/besst-usb-sdk/src/usbClient/request/firmware.js
// module id = 1066
// module chunks = 73