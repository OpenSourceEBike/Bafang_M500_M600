{"version":3,"sources":["../../src/differentialDownloader/DifferentialDownloader.ts"],"names":[],"mappings":"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","sourcesContent":["import { BlockMapDataHolder, configureRequestOptionsFromUrl, createHttpError, DigestTransform, HttpExecutor } from \"builder-util-runtime\"\nimport { BlockMap } from \"builder-util-runtime/out/blockMapApi\"\nimport { close, createWriteStream, open } from \"fs-extra-p\"\nimport { OutgoingHttpHeaders, RequestOptions } from \"http\"\nimport { Logger } from \"../main\"\nimport { copyData } from \"./DataSplitter\"\nimport { computeOperations, Operation, OperationKind } from \"./downloadPlanBuilder\"\nimport { checkIsRangesSupported, executeTasks } from \"./multipleRangeDownloader\"\n\nexport interface DifferentialDownloaderOptions {\n  readonly oldFile: string\n  readonly newUrl: string\n  readonly logger: Logger\n  readonly newFile: string\n\n  readonly requestHeaders: OutgoingHttpHeaders | null\n\n  readonly useMultipleRangeRequest?: boolean\n}\n\nexport abstract class DifferentialDownloader {\n  private readonly baseRequestOptions: RequestOptions\n\n  fileMetadataBuffer: Buffer | null = null\n\n  private readonly logger: Logger\n\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(protected readonly blockAwareFileInfo: BlockMapDataHolder, readonly httpExecutor: HttpExecutor<any>, readonly options: DifferentialDownloaderOptions) {\n    this.logger = options.logger\n    this.baseRequestOptions = configureRequestOptionsFromUrl(options.newUrl, {})\n  }\n\n  createRequestOptions(method: \"get\" | \"head\" = \"get\", newUrl?: string | null): RequestOptions {\n    return {\n      ...(newUrl == null ? this.baseRequestOptions : configureRequestOptionsFromUrl(newUrl, {})),\n      method,\n      headers: {\n        ...this.options.requestHeaders,\n        accept: \"*/*\",\n      } as any,\n    }\n  }\n\n  protected doDownload(oldBlockMap: BlockMap, newBlockMap: BlockMap): Promise<any> {\n    // we don't check other metadata like compressionMethod - generic check that it is make sense to differentially update is suitable for it\n    if (oldBlockMap.version !== newBlockMap.version) {\n      throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`)\n    }\n\n    const logger = this.logger\n    const operations = computeOperations(oldBlockMap, newBlockMap, logger)\n    if (logger.debug != null) {\n      logger.debug(JSON.stringify(operations, null, 2))\n    }\n\n    let downloadSize = 0\n    let copySize = 0\n    for (const operation of operations) {\n      const length = operation.end - operation.start\n      if (operation.kind === OperationKind.DOWNLOAD) {\n        downloadSize += length\n      }\n      else {\n        copySize += length\n      }\n    }\n\n    const newPackageSize = this.blockAwareFileInfo.size\n    if ((downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length)) !== newPackageSize) {\n      throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newPackageSize: ${newPackageSize}`)\n    }\n\n    logger.info(`Full: ${formatBytes(newPackageSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newPackageSize / 100))}%)`)\n\n    return this.downloadFile(operations)\n  }\n\n  private downloadFile(tasks: Array<Operation>): Promise<any> {\n    const fdList: Array<OpenedFile> = []\n    const closeFiles = () => {\n      return Promise.all(fdList.map(openedFile => {\n        console.log(`close ${openedFile.descriptor} ${openedFile.path}`)\n        return close(openedFile.descriptor)\n          .catch(e => {\n            this.logger.error(`cannot close file \"${openedFile.path}\": ${e}`)\n          })\n      }))\n    }\n    return this.doDownloadFile(tasks, fdList)\n      .then(closeFiles)\n      .catch(e => {\n        // then must be after catch here (since then always throws error)\n        return closeFiles()\n          .catch(closeFilesError => {\n            // closeFiles never throw error, but just to be sure\n            try {\n              this.logger.error(`cannot close files: ${closeFilesError}`)\n            }\n            catch (errorOnLog) {\n              try {\n                console.error(errorOnLog)\n              }\n              catch (ignored) {\n                // ok, give up and ignore error\n              }\n            }\n            throw e\n          })\n          .then(() => {\n            throw e\n          })\n      })\n  }\n\n  private async doDownloadFile(tasks: Array<Operation>, fdList: Array<OpenedFile>): Promise<any> {\n    const oldFileFd = await open(this.options.oldFile, \"r\")\n    fdList.push({descriptor: oldFileFd, path: this.options.oldFile})\n    const newFileFd = await open(this.options.newFile, \"w\")\n    fdList.push({descriptor: newFileFd, path: this.options.newFile})\n    const fileOut = createWriteStream(this.options.newFile, {fd: newFileFd})\n    await new Promise((resolve, reject) => {\n      const streams: Array<any> = []\n      const digestTransform = new DigestTransform(this.blockAwareFileInfo.sha512)\n      // to simply debug, do manual validation to allow file to be fully written\n      digestTransform.isValidateOnEnd = false\n      streams.push(digestTransform)\n\n      // noinspection JSArrowFunctionCanBeReplacedWithShorthand\n      fileOut.on(\"finish\", () => {\n        (fileOut.close as any)(() => {\n          // remove from fd list because closed successfully\n          fdList.splice(1, 1)\n          try {\n            digestTransform.validate()\n          }\n          catch (e) {\n            reject(e)\n            return\n          }\n\n          resolve()\n        })\n      })\n\n      streams.push(fileOut)\n\n      let lastStream = null\n      for (const stream of streams) {\n        stream.on(\"error\", reject)\n        if (lastStream == null) {\n          lastStream = stream\n        }\n        else {\n          lastStream = lastStream.pipe(stream)\n        }\n      }\n\n      const firstStream = streams[0]\n\n      let w: any\n      if (this.options.useMultipleRangeRequest) {\n        w = executeTasks(this, tasks, firstStream, oldFileFd, reject)\n      }\n      else {\n        let downloadOperationCount = 0\n        let actualUrl: string | null = null\n        this.logger.info(`Differential download: ${this.options.newUrl}`)\n        w = (index: number) => {\n          if (index >= tasks.length) {\n            if (this.fileMetadataBuffer != null) {\n              firstStream.write(this.fileMetadataBuffer)\n            }\n            firstStream.end()\n            return\n          }\n\n          const operation = tasks[index++]\n          if (operation.kind === OperationKind.COPY) {\n            copyData(operation, firstStream, oldFileFd, reject, () => w(index))\n            return\n          }\n\n          const requestOptions = this.createRequestOptions(\"get\", actualUrl)\n          const range = `bytes=${operation.start}-${operation.end - 1}`\n          requestOptions.headers!!.Range = range;\n          (requestOptions as any).redirect = \"manual\"\n\n          const debug = this.logger.debug\n          if (debug != null) {\n            debug(`download range: ${range}`)\n          }\n\n          const request = this.httpExecutor.createRequest(requestOptions, response => {\n            // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.\n            if (response.statusCode >= 400) {\n              reject(createHttpError(response))\n            }\n\n            response.pipe(firstStream, {\n              end: false\n            })\n            response.once(\"end\", () => {\n              if (++downloadOperationCount === 100) {\n                downloadOperationCount = 0\n                setTimeout(() => w(index), 1000)\n              }\n              else {\n                w(index)\n              }\n            })\n          })\n          request.on(\"redirect\", (statusCode: number, method: string, redirectUrl: string) => {\n            this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`)\n            actualUrl = redirectUrl\n            request.followRedirect()\n          })\n          this.httpExecutor.addErrorAndTimeoutHandlers(request, reject)\n          request.end()\n        }\n      }\n\n      w(0)\n    })\n  }\n\n  protected async readRemoteBytes(start: number, endInclusive: number) {\n    const buffer = Buffer.allocUnsafe((endInclusive + 1) - start)\n    const requestOptions = this.createRequestOptions()\n    requestOptions.headers!!.Range = `bytes=${start}-${endInclusive}`\n    let position = 0\n    await this.request(requestOptions, chunk => {\n      chunk.copy(buffer, position)\n      position += chunk.length\n    })\n\n    if (position !== buffer.length) {\n      throw new Error(`Received data length ${position} is not equal to expected ${buffer.length}`)\n    }\n    return buffer\n  }\n\n  private request(requestOptions: RequestOptions, dataHandler: (chunk: Buffer) => void) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpExecutor.createRequest(requestOptions, response => {\n        if (!checkIsRangesSupported(response, reject)) {\n          return\n        }\n\n        response.on(\"data\", dataHandler)\n        response.on(\"end\", () => resolve())\n      })\n      this.httpExecutor.addErrorAndTimeoutHandlers(request, reject)\n      request.end()\n    })\n  }\n}\n\nfunction formatBytes(value: number, symbol = \" KB\") {\n  return new Intl.NumberFormat(\"en\").format((value / 1024).toFixed(2) as any) + symbol\n}\n\n// safety\nfunction removeQuery(url: string) {\n  const index = url.indexOf(\"?\")\n  return index < 0 ? url : url.substring(0, index)\n}\n\ninterface OpenedFile {\n  readonly descriptor: number\n  readonly path: string\n}"],"sourceRoot":""}
