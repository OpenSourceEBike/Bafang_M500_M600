<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>S32 SDK: middleware/sbc/sbc_uja116x/source/sbc_uja116x_driver.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top" style="height:auto; width:100%"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <img id="projectlogo" style="height:auto; width:100%" alt="Logo" src="s32sdk_logo_small.jpg"/>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sbc__uja116x__driver_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sbc_uja116x_driver.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="sbc__uja116x__driver_8h_source.html">sbc_uja116x_driver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="clock__manager_8h_source.html">clock_manager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="osif_8h_source.html">osif.h</a>&quot;</code><br />
</div>
<p><a href="sbc__uja116x__driver_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrv__config__t.html">drv_config_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c6bfde7e4ab65bea537b569f116c858"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a4c6bfde7e4ab65bea537b569f116c858">sbc_write_can_others</a> (const <a class="el" href="structsbc__can__conf__t.html">sbc_can_conf_t</a> *const can)</td></tr>
<tr class="separator:a4c6bfde7e4ab65bea537b569f116c858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb331d43f041923236bf3c203e72339"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a0cb331d43f041923236bf3c203e72339">sbc_read_can_others</a> (<a class="el" href="structsbc__can__conf__t.html">sbc_can_conf_t</a> *const can)</td></tr>
<tr class="separator:a0cb331d43f041923236bf3c203e72339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da0a3dbc76c17599d68ab6e21a07c38"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a5da0a3dbc76c17599d68ab6e21a07c38">sbc_clean_events_status</a> (<a class="el" href="structsbc__evn__capt__t.html">sbc_evn_capt_t</a> *event)</td></tr>
<tr class="separator:a5da0a3dbc76c17599d68ab6e21a07c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6405bce06330e6b2d11a47c3354e851c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a6405bce06330e6b2d11a47c3354e851c">sbc_change_factories_direct</a> (const <a class="el" href="structsbc__factories__conf__t.html">sbc_factories_conf_t</a> *const factory)</td></tr>
<tr class="separator:a6405bce06330e6b2d11a47c3354e851c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77be2460b2fd9d34faf00991a717ae3d"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a77be2460b2fd9d34faf00991a717ae3d">sbc_get_factories_crc</a> (uint8_t *data)</td></tr>
<tr class="separator:a77be2460b2fd9d34faf00991a717ae3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0d44b85038752c6776ecb139f92b08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a6c0d44b85038752c6776ecb139f92b08">SBC_InitDriver</a> (const uint32_t lpspiInstance)</td></tr>
<tr class="memdesc:a6c0d44b85038752c6776ecb139f92b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function internally stores LPSPI instance used by the driver.  <a href="#a6c0d44b85038752c6776ecb139f92b08">More...</a><br /></td></tr>
<tr class="separator:a6c0d44b85038752c6776ecb139f92b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaccb48fcb02b56d66317c3dc96c6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#affaccb48fcb02b56d66317c3dc96c6dc">SBC_InitDevice</a> (const <a class="el" href="structsbc__int__config__t.html">sbc_int_config_t</a> *const config)</td></tr>
<tr class="memdesc:affaccb48fcb02b56d66317c3dc96c6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes all registers.  <a href="#affaccb48fcb02b56d66317c3dc96c6dc">More...</a><br /></td></tr>
<tr class="separator:affaccb48fcb02b56d66317c3dc96c6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ae0462b7d1daf222c2cf2c79e22aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#ac5ae0462b7d1daf222c2cf2c79e22aae">SBC_SetVreg</a> (const <a class="el" href="structsbc__regulator__ctr__t.html">sbc_regulator_ctr_t</a> *const regulatorCtr)</td></tr>
<tr class="memdesc:ac5ae0462b7d1daf222c2cf2c79e22aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures Regulator control registers.  <a href="#ac5ae0462b7d1daf222c2cf2c79e22aae">More...</a><br /></td></tr>
<tr class="separator:ac5ae0462b7d1daf222c2cf2c79e22aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692027f43d2c69d5e90b83a77ac220a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a692027f43d2c69d5e90b83a77ac220a9">SBC_GetVreg</a> (<a class="el" href="structsbc__regulator__ctr__t.html">sbc_regulator_ctr_t</a> *const regulatorCtr)</td></tr>
<tr class="memdesc:a692027f43d2c69d5e90b83a77ac220a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads Regulator control registers.  <a href="#a692027f43d2c69d5e90b83a77ac220a9">More...</a><br /></td></tr>
<tr class="separator:a692027f43d2c69d5e90b83a77ac220a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadbfb4ce7b6a4965d4ff3b26654f05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#acadbfb4ce7b6a4965d4ff3b26654f05a">SBC_SetWatchdog</a> (const <a class="el" href="structsbc__wtdog__ctr__t.html">sbc_wtdog_ctr_t</a> *const wtdog)</td></tr>
<tr class="memdesc:acadbfb4ce7b6a4965d4ff3b26654f05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures Watchdog control register (0x00).  <a href="#acadbfb4ce7b6a4965d4ff3b26654f05a">More...</a><br /></td></tr>
<tr class="separator:acadbfb4ce7b6a4965d4ff3b26654f05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdbd5ed333378be018d787c782c4521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a8cdbd5ed333378be018d787c782c4521">SBC_GetWatchdog</a> (<a class="el" href="structsbc__wtdog__ctr__t.html">sbc_wtdog_ctr_t</a> *const wtdog)</td></tr>
<tr class="memdesc:a8cdbd5ed333378be018d787c782c4521"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads Watchdog control register (0x00).  <a href="#a8cdbd5ed333378be018d787c782c4521">More...</a><br /></td></tr>
<tr class="separator:a8cdbd5ed333378be018d787c782c4521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5812ff87ceb55fed36f2229bef26ca1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a5812ff87ceb55fed36f2229bef26ca1c">SBC_FeedWatchdog</a> (void)</td></tr>
<tr class="memdesc:a5812ff87ceb55fed36f2229bef26ca1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function refreshes watchdog period by writing byte to the SBC watchdog register. This function must be called periodically according Watchdog mode control and Nominal watchdog period settings. Note: Unxpected behaviour can happend if watchdog mode is set to timeout period and watchdog is triggered exactly at 50% of period. Be sure you trigger watchdog before 50% or above 50% of watchdog period.  <a href="#a5812ff87ceb55fed36f2229bef26ca1c">More...</a><br /></td></tr>
<tr class="separator:a5812ff87ceb55fed36f2229bef26ca1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f12391434a44c059e7ad329947620f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a39f12391434a44c059e7ad329947620f">SBC_SetMode</a> (const <a class="el" href="group__sbc__uja116x__driver.html#gaa4630d8955028b5532168f9bf1c7d340">sbc_mode_mc_t</a> mode)</td></tr>
<tr class="memdesc:a39f12391434a44c059e7ad329947620f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to Mode control register. (0x01).  <a href="#a39f12391434a44c059e7ad329947620f">More...</a><br /></td></tr>
<tr class="separator:a39f12391434a44c059e7ad329947620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ccf7b10deb391ca33d519f922ed28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#aa2ccf7b10deb391ca33d519f922ed28d">SBC_GetMode</a> (<a class="el" href="group__sbc__uja116x__driver.html#gaa4630d8955028b5532168f9bf1c7d340">sbc_mode_mc_t</a> *const mode)</td></tr>
<tr class="memdesc:aa2ccf7b10deb391ca33d519f922ed28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads Mode control register. (0x01).  <a href="#aa2ccf7b10deb391ca33d519f922ed28d">More...</a><br /></td></tr>
<tr class="separator:aa2ccf7b10deb391ca33d519f922ed28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b26e3c13fa67542548ba8f2c9b04ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#ac0b26e3c13fa67542548ba8f2c9b04ae">SBC_SetFailSafe</a> (const <a class="el" href="group__sbc__uja116x__driver.html#ga30987b772fc799e9e00bc7355dc6edeb">sbc_fail_safe_lhc_t</a> lhc, const <a class="el" href="group__sbc__uja116x__driver.html#gad8b22d2a90a70c8494d1b9f3dd7c5cb4">sbc_fail_safe_rcc_t</a> *const rcc)</td></tr>
<tr class="memdesc:ac0b26e3c13fa67542548ba8f2c9b04ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to Fail-safe control register (0x02). The dedicated LIMP pin can be used to enable so called limp home hardware in the event of a serious ECU failure. Detectable failure conditions include SBC overtemperature events, loss of watchdog service, short-circuits on pins RSTN or V1 and user-initiated or external reset events. The LIMP pin is a battery-robust, active-LOW, open-drain output. The LIMP pin can also be forced LOW by setting bit LHC in the Fail-safe control register. The limp-home function and the reset counter are disabled in Forced Normal mode. The LIMP pin is floating, RCC remains unchanged and bit LHC = 0. RCC -reset counter control. incremented every time the SBC enters Reset mode while FNMC = 0; RCC overflows from 11 to 00; default at power-on is 00. For ignore settings of rcc use NULL pointer or otherwise send pointer to variable. This function is not available on UJA1168 device variants.  <a href="#ac0b26e3c13fa67542548ba8f2c9b04ae">More...</a><br /></td></tr>
<tr class="separator:ac0b26e3c13fa67542548ba8f2c9b04ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57868d15c4de6ca01760120af0e19536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a57868d15c4de6ca01760120af0e19536">SBC_GetFailSafe</a> (<a class="el" href="group__sbc__uja116x__driver.html#ga30987b772fc799e9e00bc7355dc6edeb">sbc_fail_safe_lhc_t</a> *const lhc, <a class="el" href="group__sbc__uja116x__driver.html#gad8b22d2a90a70c8494d1b9f3dd7c5cb4">sbc_fail_safe_rcc_t</a> *const rcc)</td></tr>
<tr class="memdesc:a57868d15c4de6ca01760120af0e19536"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads from Fail-safe control register (0x02). The dedicated LIMP pin can be used to enable so called limp home hardware in the event of a serious ECU failure. Detectable failure conditions include SBC overtemperature events, loss of watchdog service, short-circuits on pins RSTN or V1 and user-initiated or external reset events. The LIMP pin is a battery-robust, active-LOW, open-drain output. The LIMP pin can also be forced LOW by setting bit LHC in the Fail-safe control register. The limp-home function and the reset counter are disabled in Forced Normal mode. The LIMP pin is floating, RCC remains unchanged and bit LHC = 0. This function is not available on UJA1168 device variants.  <a href="#a57868d15c4de6ca01760120af0e19536">More...</a><br /></td></tr>
<tr class="separator:a57868d15c4de6ca01760120af0e19536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93acdb00340b7657f409edf8d35f036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#ac93acdb00340b7657f409edf8d35f036">SBC_SetSystemEvents</a> (const <a class="el" href="structsbc__sys__evnt__t.html">sbc_sys_evnt_t</a> *const sysEvnt)</td></tr>
<tr class="memdesc:ac93acdb00340b7657f409edf8d35f036"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes System event capture enable register (0x04). This function enables or disables overtemperature warning, SPI failure enable.  <a href="#ac93acdb00340b7657f409edf8d35f036">More...</a><br /></td></tr>
<tr class="separator:ac93acdb00340b7657f409edf8d35f036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b71181a1caf73cc7693ad21917d06bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a2b71181a1caf73cc7693ad21917d06bd">SBC_GetSystemEvents</a> (<a class="el" href="structsbc__sys__evnt__t.html">sbc_sys_evnt_t</a> *const sysEvnt)</td></tr>
<tr class="memdesc:a2b71181a1caf73cc7693ad21917d06bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads System event capture enable register (0x04). This function reads content of overtemperature warning and SPI failure settings.  <a href="#a2b71181a1caf73cc7693ad21917d06bd">More...</a><br /></td></tr>
<tr class="separator:a2b71181a1caf73cc7693ad21917d06bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5902e0d671d70c4adab5ba63c27cd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#ada5902e0d671d70c4adab5ba63c27cd7">SBC_SetLock</a> (const <a class="el" href="group__sbc__uja116x__driver.html#ga59009e638ca7c7fe656bcf0447a32ee9">sbc_lock_t</a> lockMask)</td></tr>
<tr class="memdesc:ada5902e0d671d70c4adab5ba63c27cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to Lock control register (0x0A). Sections of the register address area can be write-protected to protect against unintended modifications. This facility only protects locked bits from being modified via the SPI and will not prevent the UJA116xA updating status registers etc. For SPI write disable set lock bit to 1. This is mask for set lock control register.  <a href="#ada5902e0d671d70c4adab5ba63c27cd7">More...</a><br /></td></tr>
<tr class="separator:ada5902e0d671d70c4adab5ba63c27cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a937d39d2604bdfc7c9be1f6f84c110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a7a937d39d2604bdfc7c9be1f6f84c110">SBC_GetLock</a> (<a class="el" href="group__sbc__uja116x__driver.html#ga59009e638ca7c7fe656bcf0447a32ee9">sbc_lock_t</a> *const lockMask)</td></tr>
<tr class="memdesc:a7a937d39d2604bdfc7c9be1f6f84c110"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads Lock control register (0x0A). Sections of the register address area can be write-protected to protect against unintended modifications. This facility only protects locked bits from being modified via the SPI and will not prevent the UJA116xA updating status registers etc. For SPI write disable set lock bit to 1. This is mask for set lock control register.  <a href="#a7a937d39d2604bdfc7c9be1f6f84c110">More...</a><br /></td></tr>
<tr class="separator:a7a937d39d2604bdfc7c9be1f6f84c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7668330a4e8b1e32e685ae904a4c37f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#ac7668330a4e8b1e32e685ae904a4c37f">SBC_SetCanConfig</a> (const <a class="el" href="structsbc__can__conf__t.html">sbc_can_conf_t</a> *const can)</td></tr>
<tr class="memdesc:ac7668330a4e8b1e32e685ae904a4c37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures CAN peripheral behavior. This function configures CAN peripheral behavior. This function configures several registers which configure CAN. It contains CAN control register, Transceiver event capture enable register, CAN data rate selection, ID registers, ID mask registers, Frame control register, Data mask 0 - 7 configuration.  <a href="#ac7668330a4e8b1e32e685ae904a4c37f">More...</a><br /></td></tr>
<tr class="separator:ac7668330a4e8b1e32e685ae904a4c37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b72f33b50b16c89e487409402f25c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a2b72f33b50b16c89e487409402f25c8a">SBC_GetCanConfig</a> (<a class="el" href="structsbc__can__conf__t.html">sbc_can_conf_t</a> *const can)</td></tr>
<tr class="memdesc:a2b72f33b50b16c89e487409402f25c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads CAN peripheral settings. This function configures CAN peripheral behavior. This function configures several registers which configure CAN. It contains CAN control register, Transceiver event capture enable register, CAN data rate selection, ID registers, ID mask registers, Frame control register, Data mask 0 - 7 configuration.  <a href="#a2b72f33b50b16c89e487409402f25c8a">More...</a><br /></td></tr>
<tr class="separator:a2b72f33b50b16c89e487409402f25c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec84a1ac7469e4e78ba2ab315e97a6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#aaec84a1ac7469e4e78ba2ab315e97a6c">SBC_SetWakePin</a> (const <a class="el" href="structsbc__wake__t.html">sbc_wake_t</a> *const wakePin)</td></tr>
<tr class="memdesc:aaec84a1ac7469e4e78ba2ab315e97a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to WAKE pin event capture enable register (0x4C). Local wake-up is enabled via bits WPRE and WPFE in the WAKE pin event capture enable register. A wake-up event is triggered by a LOW-to-HIGH (ifWPRE = 1) and/or a HIGH-to-LOW (if WPFE = 1) transition on the WAKE pin. This arrangement allows for maximum flexibility when designing a local wake-up circuit. In applications that do not use the local wake-up facility, local wake-up should be disabled and the WAKE pin connected to GND.  <a href="#aaec84a1ac7469e4e78ba2ab315e97a6c">More...</a><br /></td></tr>
<tr class="separator:aaec84a1ac7469e4e78ba2ab315e97a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6157c1694620d002d948e542e001dde0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a6157c1694620d002d948e542e001dde0">SBC_GetWakePin</a> (<a class="el" href="structsbc__wake__t.html">sbc_wake_t</a> *const wakePin)</td></tr>
<tr class="memdesc:a6157c1694620d002d948e542e001dde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads WAKE pin event capture enable register (0x4C). Local wake-up is enabled via bits WPRE and WPFE in the WAKE pin event capture enable register. A wake-up event is triggered by a LOW-to-HIGH (ifWPRE = 1) and/or a HIGH-to-LOW (if WPFE = 1) transition on the WAKE pin. This arrangement allows for maximum flexibility when designing a local wake-up circuit. In applications that do not use the local wake-up facility, local wake-up should be disabled and the WAKE pin connected to GND.  <a href="#a6157c1694620d002d948e542e001dde0">More...</a><br /></td></tr>
<tr class="separator:a6157c1694620d002d948e542e001dde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b2fe6072cf56154750e663bd92f913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a23b2fe6072cf56154750e663bd92f913">SBC_GetMainStatus</a> (<a class="el" href="structsbc__main__status__t.html">sbc_main_status_t</a> *const mainStatus)</td></tr>
<tr class="memdesc:a23b2fe6072cf56154750e663bd92f913"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads Main status register. This function will clear R/W registers automatically after reading.  <a href="#a23b2fe6072cf56154750e663bd92f913">More...</a><br /></td></tr>
<tr class="separator:a23b2fe6072cf56154750e663bd92f913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fc083190070d447ca84233068a43ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a77fc083190070d447ca84233068a43ed">SBC_GetWatchdogStatus</a> (<a class="el" href="structsbc__wtdog__status__t.html">sbc_wtdog_status_t</a> *const watchdogStatus)</td></tr>
<tr class="memdesc:a77fc083190070d447ca84233068a43ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads Watchdog status register. This function will clear R/W registers automatically after reading.  <a href="#a77fc083190070d447ca84233068a43ed">More...</a><br /></td></tr>
<tr class="separator:a77fc083190070d447ca84233068a43ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d42d0cd3cc230a1c4ab950d1cf2916a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a1d42d0cd3cc230a1c4ab950d1cf2916a">SBC_GetSupplyStatus</a> (<a class="el" href="structsbc__supply__status__t.html">sbc_supply_status_t</a> *const supStatus)</td></tr>
<tr class="memdesc:a1d42d0cd3cc230a1c4ab950d1cf2916a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reads Supply voltage status register. This function clear R/W status after reading writing 0 to register. It contains V2/VEXT status and V1 status.  <a href="#a1d42d0cd3cc230a1c4ab950d1cf2916a">More...</a><br /></td></tr>
<tr class="separator:a1d42d0cd3cc230a1c4ab950d1cf2916a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc90a811ed60eb90d8bd0ffacb9abb59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#afc90a811ed60eb90d8bd0ffacb9abb59">SBC_GetCanStatus</a> (<a class="el" href="structsbc__trans__stat__t.html">sbc_trans_stat_t</a> *const transStatus)</td></tr>
<tr class="memdesc:afc90a811ed60eb90d8bd0ffacb9abb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reads Transceiver status register. It contains CAN transceiver status, CAN partial networking error, CAN partial networking status, CAN oscillator status, CAN-bus silence status, VCAN status, CAN failure status.  <a href="#afc90a811ed60eb90d8bd0ffacb9abb59">More...</a><br /></td></tr>
<tr class="separator:afc90a811ed60eb90d8bd0ffacb9abb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c48679243df652d050f8ad889eb1ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a6c48679243df652d050f8ad889eb1ec9">SBC_GetWakeStatus</a> (<a class="el" href="group__sbc__uja116x__driver.html#ga04168b357f17b935efea0f3033d6ef31">sbc_wake_stat_wpvs_t</a> *const wakeStatus)</td></tr>
<tr class="memdesc:a6c48679243df652d050f8ad889eb1ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reads WAKE pin status register. This function reads switching threshold of voltage on WAKE pin.  <a href="#a6c48679243df652d050f8ad889eb1ec9">More...</a><br /></td></tr>
<tr class="separator:a6c48679243df652d050f8ad889eb1ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70494291fcb7ba565cef6d9140cb9bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a70494291fcb7ba565cef6d9140cb9bb5">SBC_GetEventsStatus</a> (<a class="el" href="structsbc__evn__capt__t.html">sbc_evn_capt_t</a> *const events)</td></tr>
<tr class="memdesc:a70494291fcb7ba565cef6d9140cb9bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reads Event capture registers. This function reads switching threshold of voltage on WAKE pin. This functions reads global events statuses: Global event status, System event status, Supply event status, Transceiver event status, WAKE pin event status.  <a href="#a70494291fcb7ba565cef6d9140cb9bb5">More...</a><br /></td></tr>
<tr class="separator:a70494291fcb7ba565cef6d9140cb9bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3526442849f8ce17b0644774ccd63ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a3526442849f8ce17b0644774ccd63ff8">SBC_CleanEvents</a> (const <a class="el" href="structsbc__evn__capt__t.html">sbc_evn_capt_t</a> *const events)</td></tr>
<tr class="memdesc:a3526442849f8ce17b0644774ccd63ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears Event capture registers. It contains Global event status, System event status, Supply event status, Transceiver event status, WAKE pin event status. This function write 1 to bit which should be delete. After an event source has been identified, the status flag should be cleared (set to 0) by writing 1 to the relevant status bit (writing 0 will have no effect). Write true value to appropriate enumeration.  <a href="#a3526442849f8ce17b0644774ccd63ff8">More...</a><br /></td></tr>
<tr class="separator:a3526442849f8ce17b0644774ccd63ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92713261bc91f589d36acb816ee6809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#ae92713261bc91f589d36acb816ee6809">SBC_GetAllStatus</a> (<a class="el" href="structsbc__status__group__t.html">sbc_status_group_t</a> *const status)</td></tr>
<tr class="memdesc:ae92713261bc91f589d36acb816ee6809"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads all statuses from SBC device. It reads all status registers: Main status and Watchdog status, Supply voltage status, Transceiver status, WAKE pin status, Event capture registers.  <a href="#ae92713261bc91f589d36acb816ee6809">More...</a><br /></td></tr>
<tr class="separator:ae92713261bc91f589d36acb816ee6809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723f076123b5773418b1f85050c0f764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a723f076123b5773418b1f85050c0f764">SBC_GetMtpnvStatus</a> (<a class="el" href="structsbc__mtpnv__stat__t.html">sbc_mtpnv_stat_t</a> *const mtpnv)</td></tr>
<tr class="memdesc:a723f076123b5773418b1f85050c0f764"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads MTPNV status register. The MTPNV cells can be reprogrammed a maximum of 200 times (Ncy(W)MTP). Bit NVMPS in the MTPNV status register indicates whether the non-volatile cells can be reprogrammed. This register also contains a write counter, WRCNTS, that is incremented each time the MTPNV cells are reprogrammed (up to a maximum value of 111111; there is no overflow; performing a factory reset also increments the counter). This counter is provided for information purposes only; reprogramming will not be rejected when it reaches its maximum value.  <a href="#a723f076123b5773418b1f85050c0f764">More...</a><br /></td></tr>
<tr class="separator:a723f076123b5773418b1f85050c0f764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b706fb2fffdb0b3ef1fd775b2ff70f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a4b706fb2fffdb0b3ef1fd775b2ff70f7">SBC_GetFactoriesSettings</a> (<a class="el" href="structsbc__factories__conf__t.html">sbc_factories_conf_t</a> *const factoriesConf)</td></tr>
<tr class="memdesc:a4b706fb2fffdb0b3ef1fd775b2ff70f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads Start-up control register and SBC configuration control register. It is non-volatile memory with limited write access. The UJA116xA contains Multiple Time Programmable Non-Volatile (MTPNV) memory cells that allow some of the default device settings to be reconfigured. The MTPNV memory address range is from 0x73 to 0x74. NXP delivers the UJA116xA in so-called Forced Normal mode, also referred to as the factory preset configuration. In order to change the default settings, the device must be in Forced Normal mode with FNMC = 1 and NVMPS = 1. In Forced Normal mode, the watchdog is disabled, all regulators are on and the CAN transceiver is in Active mode.  <a href="#a4b706fb2fffdb0b3ef1fd775b2ff70f7">More...</a><br /></td></tr>
<tr class="separator:a4b706fb2fffdb0b3ef1fd775b2ff70f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29485e68d9f6a2534edc7843e33755be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a29485e68d9f6a2534edc7843e33755be">SBC_ChangeFactoriesSettings</a> (const <a class="el" href="structsbc__factories__conf__t.html">sbc_factories_conf_t</a> *const newConf)</td></tr>
<tr class="memdesc:a29485e68d9f6a2534edc7843e33755be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets Start-up control register and SBC configuration control register. It is non-volatile memory with limited write access. The UJA116xA contains Multiple Time Programmable Non-Volatile (MTPNV) memory cells that allow some of the default device settings to be reconfigured. The MTPNV memory address range is from 0x73 to 0x74. NXP delivers the UJA116xA in so-called Forced Normal mode, also referred to as the factory preset configuration. In order to change the default settings, the device must be in Forced Normal mode with FNMC = 1 and NVMPS = 1. In Forced Normal mode, the watchdog is disabled, all regulators are on and the CAN transceiver is in Active mode. Note for default settings see <a class="el" href="structsbc__factories__conf__t.html" title="Factory configuration structure. It contains Start-up control register and SBC configuration control ...">sbc_factories_conf_t</a> comment. If the device has been programmed previously, the factory presets may need to be restored before reprogramming can begin. When the factory presets have been restored successfully, a system reset is generated automatically and UJA116xA switches back to Forced Normal mode. Factory preset values are restored if the following conditions apply continuously for at least td(MTPNV) during battery power-up: -pin RSTN is held LOW -CANH is pulled up to VBAT -CANL is pulled down to GND.  <a href="#a29485e68d9f6a2534edc7843e33755be">More...</a><br /></td></tr>
<tr class="separator:a29485e68d9f6a2534edc7843e33755be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3a71f6be31114f1d3fdf5db4b1efaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a2f3a71f6be31114f1d3fdf5db4b1efaf">SBC_DataTransfer</a> (const <a class="el" href="group__sbc__uja116x__driver.html#ga1bece500b530982ab2ceec8c57e92c7b">sbc_register_t</a> regName, const uint8_t *const sendData, uint8_t *const receiveData)</td></tr>
<tr class="memdesc:a2f3a71f6be31114f1d3fdf5db4b1efaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends data over LSPI to SBC device. This function sends 8 bites to SBC device register according device address which is selected. This transfer uses 16bit LSPI. CS polarity - active low, clock phase on second edge. Clock polarity active high.  <a href="#a2f3a71f6be31114f1d3fdf5db4b1efaf">More...</a><br /></td></tr>
<tr class="separator:a2f3a71f6be31114f1d3fdf5db4b1efaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a322d7f793591717b1569193f6bf116c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdrv__config__t.html">drv_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbc__uja116x__driver_8c.html#a322d7f793591717b1569193f6bf116c2">g_drvConfig</a></td></tr>
<tr class="separator:a322d7f793591717b1569193f6bf116c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6405bce06330e6b2d11a47c3354e851c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> sbc_change_factories_direct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__factories__conf__t.html">sbc_factories_conf_t</a> *const&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01849">1849</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a29485e68d9f6a2534edc7843e33755be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_ChangeFactoriesSettings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__factories__conf__t.html">sbc_factories_conf_t</a> *const&#160;</td>
          <td class="paramname"><em>newConf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets Start-up control register and SBC configuration control register. It is non-volatile memory with limited write access. The UJA116xA contains Multiple Time Programmable Non-Volatile (MTPNV) memory cells that allow some of the default device settings to be reconfigured. The MTPNV memory address range is from 0x73 to 0x74. NXP delivers the UJA116xA in so-called Forced Normal mode, also referred to as the factory preset configuration. In order to change the default settings, the device must be in Forced Normal mode with FNMC = 1 and NVMPS = 1. In Forced Normal mode, the watchdog is disabled, all regulators are on and the CAN transceiver is in Active mode. Note for default settings see <a class="el" href="structsbc__factories__conf__t.html" title="Factory configuration structure. It contains Start-up control register and SBC configuration control ...">sbc_factories_conf_t</a> comment. If the device has been programmed previously, the factory presets may need to be restored before reprogramming can begin. When the factory presets have been restored successfully, a system reset is generated automatically and UJA116xA switches back to Forced Normal mode. Factory preset values are restored if the following conditions apply continuously for at least td(MTPNV) during battery power-up: -pin RSTN is held LOW -CANH is pulled up to VBAT -CANL is pulled down to GND. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newConf</td><td>value of this variable will be write to Start-up control register and SBC configuration control register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01580">1580</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5da0a3dbc76c17599d68ab6e21a07c38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sbc_clean_events_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__evn__capt__t.html">sbc_evn_capt_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01786">1786</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3526442849f8ce17b0644774ccd63ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_CleanEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__evn__capt__t.html">sbc_evn_capt_t</a> *const&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears Event capture registers. It contains Global event status, System event status, Supply event status, Transceiver event status, WAKE pin event status. This function write 1 to bit which should be delete. After an event source has been identified, the status flag should be cleared (set to 0) by writing 1 to the relevant status bit (writing 0 will have no effect). Write true value to appropriate enumeration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>variable for clear Event capture registers, set status to 1 for clear appropriate status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01338">1338</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2f3a71f6be31114f1d3fdf5db4b1efaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_DataTransfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__sbc__uja116x__driver.html#ga1bece500b530982ab2ceec8c57e92c7b">sbc_register_t</a>&#160;</td>
          <td class="paramname"><em>regName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>receiveData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends data over LSPI to SBC device. This function sends 8 bites to SBC device register according device address which is selected. This transfer uses 16bit LSPI. CS polarity - active low, clock phase on second edge. Clock polarity active high. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regName</td><td>this is register name for access. </td></tr>
    <tr><td class="paramname">sendData</td><td>pointer of 8 bits variable which contains data for writing to register of SBC device. Use NULL pointer for data reading. </td></tr>
    <tr><td class="paramname">receiveData</td><td>pointer of 8 bits variable which contains data for reading from SBC device. Use NULL pointer for data writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01627">1627</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5812ff87ceb55fed36f2229bef26ca1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBC_FeedWatchdog </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function refreshes watchdog period by writing byte to the SBC watchdog register. This function must be called periodically according Watchdog mode control and Nominal watchdog period settings. Note: Unxpected behaviour can happend if watchdog mode is set to timeout period and watchdog is triggered exactly at 50% of period. Be sure you trigger watchdog before 50% or above 50% of watchdog period. </p>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00412">412</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a77be2460b2fd9d34faf00991a717ae3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t sbc_get_factories_crc </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01815">1815</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae92713261bc91f589d36acb816ee6809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetAllStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__status__group__t.html">sbc_status_group_t</a> *const&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads all statuses from SBC device. It reads all status registers: Main status and Watchdog status, Supply voltage status, Transceiver status, WAKE pin status, Event capture registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>variable for storing all status registers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01406">1406</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2b72f33b50b16c89e487409402f25c8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetCanConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__can__conf__t.html">sbc_can_conf_t</a> *const&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads CAN peripheral settings. This function configures CAN peripheral behavior. This function configures several registers which configure CAN. It contains CAN control register, Transceiver event capture enable register, CAN data rate selection, ID registers, ID mask registers, Frame control register, Data mask 0 - 7 configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can</td><td>reads CAN peripheral settings from SBC device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00873">873</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="afc90a811ed60eb90d8bd0ffacb9abb59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetCanStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__trans__stat__t.html">sbc_trans_stat_t</a> *const&#160;</td>
          <td class="paramname"><em>transStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions reads Transceiver status register. It contains CAN transceiver status, CAN partial networking error, CAN partial networking status, CAN oscillator status, CAN-bus silence status, VCAN status, CAN failure status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transStatus</td><td>variable for storing Transceiver status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01143">1143</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a70494291fcb7ba565cef6d9140cb9bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetEventsStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__evn__capt__t.html">sbc_evn_capt_t</a> *const&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions reads Event capture registers. This function reads switching threshold of voltage on WAKE pin. This functions reads global events statuses: Global event status, System event status, Supply event status, Transceiver event status, WAKE pin event status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>variable for storing Event capture registers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01221">1221</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4b706fb2fffdb0b3ef1fd775b2ff70f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetFactoriesSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__factories__conf__t.html">sbc_factories_conf_t</a> *const&#160;</td>
          <td class="paramname"><em>factoriesConf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads Start-up control register and SBC configuration control register. It is non-volatile memory with limited write access. The UJA116xA contains Multiple Time Programmable Non-Volatile (MTPNV) memory cells that allow some of the default device settings to be reconfigured. The MTPNV memory address range is from 0x73 to 0x74. NXP delivers the UJA116xA in so-called Forced Normal mode, also referred to as the factory preset configuration. In order to change the default settings, the device must be in Forced Normal mode with FNMC = 1 and NVMPS = 1. In Forced Normal mode, the watchdog is disabled, all regulators are on and the CAN transceiver is in Active mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factoriesConf</td><td>variable for storing Start-up control register and SBC configuration control register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01510">1510</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a57868d15c4de6ca01760120af0e19536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetFailSafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sbc__uja116x__driver.html#ga30987b772fc799e9e00bc7355dc6edeb">sbc_fail_safe_lhc_t</a> *const&#160;</td>
          <td class="paramname"><em>lhc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sbc__uja116x__driver.html#gad8b22d2a90a70c8494d1b9f3dd7c5cb4">sbc_fail_safe_rcc_t</a> *const&#160;</td>
          <td class="paramname"><em>rcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads from Fail-safe control register (0x02). The dedicated LIMP pin can be used to enable so called limp home hardware in the event of a serious ECU failure. Detectable failure conditions include SBC overtemperature events, loss of watchdog service, short-circuits on pins RSTN or V1 and user-initiated or external reset events. The LIMP pin is a battery-robust, active-LOW, open-drain output. The LIMP pin can also be forced LOW by setting bit LHC in the Fail-safe control register. The limp-home function and the reset counter are disabled in Forced Normal mode. The LIMP pin is floating, RCC remains unchanged and bit LHC = 0. This function is not available on UJA1168 device variants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhc</td><td>Variable for reading of limp home control. </td></tr>
    <tr><td class="paramname">rcc</td><td>Pointer to rcc. Use null pointer or wrong value for ignore parameter or empty for reading.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00612">612</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7a937d39d2604bdfc7c9be1f6f84c110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sbc__uja116x__driver.html#ga59009e638ca7c7fe656bcf0447a32ee9">sbc_lock_t</a> *const&#160;</td>
          <td class="paramname"><em>lockMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads Lock control register (0x0A). Sections of the register address area can be write-protected to protect against unintended modifications. This facility only protects locked bits from being modified via the SPI and will not prevent the UJA116xA updating status registers etc. For SPI write disable set lock bit to 1. This is mask for set lock control register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lockMask</td><td>reads CAN peripheral settings from SBC device. SBC device bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00771">771</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a23b2fe6072cf56154750e663bd92f913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetMainStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__main__status__t.html">sbc_main_status_t</a> *const&#160;</td>
          <td class="paramname"><em>mainStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads Main status register. This function will clear R/W registers automatically after reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mainStatus</td><td>variable for storing Status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01021">1021</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa2ccf7b10deb391ca33d519f922ed28d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sbc__uja116x__driver.html#gaa4630d8955028b5532168f9bf1c7d340">sbc_mode_mc_t</a> *const&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads Mode control register. (0x01). </p>
<p>Normal mode is the active operating mode. In this mode, all the hardware on the device is available and can be activated. Voltage regulator V1 is enabled to supply the microcontroller. Standby mode is the first-level power-saving mode of the UJA116xA, offering reduced current consumption. The transceiver is unable to transmit or receive data in Standby mode. The SPI remains enabled and V1 is still active; the watchdog is active (in Timeout mode) if enabled. The behavior of V2/VEXT is determined by the SPI setting. Sleep mode is the second-level power-saving mode of the UJA116xA. The difference between Sleep and Standby modes is that V1 is off in Sleep mode and temperature protection is inactive. Note event status are cleared before device move to sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>variable for store device mode - Normal, StandBy, Sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00506">506</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a723f076123b5773418b1f85050c0f764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetMtpnvStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__mtpnv__stat__t.html">sbc_mtpnv_stat_t</a> *const&#160;</td>
          <td class="paramname"><em>mtpnv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads MTPNV status register. The MTPNV cells can be reprogrammed a maximum of 200 times (Ncy(W)MTP). Bit NVMPS in the MTPNV status register indicates whether the non-volatile cells can be reprogrammed. This register also contains a write counter, WRCNTS, that is incremented each time the MTPNV cells are reprogrammed (up to a maximum value of 111111; there is no overflow; performing a factory reset also increments the counter). This counter is provided for information purposes only; reprogramming will not be rejected when it reaches its maximum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtpnv</td><td>variable for storing MTPNV status registers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01462">1462</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1d42d0cd3cc230a1c4ab950d1cf2916a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetSupplyStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__supply__status__t.html">sbc_supply_status_t</a> *const&#160;</td>
          <td class="paramname"><em>supStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions reads Supply voltage status register. This function clear R/W status after reading writing 0 to register. It contains V2/VEXT status and V1 status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">supStatus</td><td>variable for storing Supply voltage status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01101">1101</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2b71181a1caf73cc7693ad21917d06bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetSystemEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__sys__evnt__t.html">sbc_sys_evnt_t</a> *const&#160;</td>
          <td class="paramname"><em>sysEvnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads System event capture enable register (0x04). This function reads content of overtemperature warning and SPI failure settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sysEvnt</td><td>system event capture enable register structure for storing result from SBC device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00694">694</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a692027f43d2c69d5e90b83a77ac220a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetVreg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__regulator__ctr__t.html">sbc_regulator_ctr_t</a> *const&#160;</td>
          <td class="paramname"><em>regulatorCtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads Regulator control registers. </p>
<p>Regulator control (0x10), Supply event enable(0x1C).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regulatorCtr</td><td>regulator registers structure where device data will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00231">231</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6157c1694620d002d948e542e001dde0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetWakePin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__wake__t.html">sbc_wake_t</a> *const&#160;</td>
          <td class="paramname"><em>wakePin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads WAKE pin event capture enable register (0x4C). Local wake-up is enabled via bits WPRE and WPFE in the WAKE pin event capture enable register. A wake-up event is triggered by a LOW-to-HIGH (ifWPRE = 1) and/or a HIGH-to-LOW (if WPFE = 1) transition on the WAKE pin. This arrangement allows for maximum flexibility when designing a local wake-up circuit. In applications that do not use the local wake-up facility, local wake-up should be disabled and the WAKE pin connected to GND. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakePin</td><td>reads configuration to WAKE pin event capture enable register of SBC device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00983">983</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6c48679243df652d050f8ad889eb1ec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetWakeStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sbc__uja116x__driver.html#ga04168b357f17b935efea0f3033d6ef31">sbc_wake_stat_wpvs_t</a> *const&#160;</td>
          <td class="paramname"><em>wakeStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions reads WAKE pin status register. This function reads switching threshold of voltage on WAKE pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakeStatus</td><td>variable for storing WAKE pin status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01184">1184</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8cdbd5ed333378be018d787c782c4521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetWatchdog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__wtdog__ctr__t.html">sbc_wtdog_ctr_t</a> *const&#160;</td>
          <td class="paramname"><em>wtdog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads Watchdog control register (0x00). </p>
<p>This function reads Watchdog mode control, and nominal watchdog period.</p>
<p>The UJA116xA contains a watchdog that supports three operating modes: Window, Timeout and Autonomous. In Window mode (available only in SBC Normal mode), a watchdog trigger event within a defined watchdog window triggers and resets the watchdog timer. In Timeout mode, the watchdog runs continuously and can be triggered and reset at any time within the watchdog period by a watchdog trigger. Watchdog time-out mode can also be used for cyclic wake-up of the microcontroller. In Autonomous mode, the watchdog can be off or autonomously in Timeout mode, depending on the selected SBC mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wtdog</td><td>watchdog registers structure which will be read from device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00369">369</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a77fc083190070d447ca84233068a43ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_GetWatchdogStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__wtdog__status__t.html">sbc_wtdog_status_t</a> *const&#160;</td>
          <td class="paramname"><em>watchdogStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads Watchdog status register. This function will clear R/W registers automatically after reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">watchdogStatus</td><td>variable for storing Status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01059">1059</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="affaccb48fcb02b56d66317c3dc96c6dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_InitDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__int__config__t.html">sbc_int_config_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes all registers. </p>
<p>The function needs to be used in sequence with SBC_InitDriver, for example when reading pre-reset or wake-up events using SBC_GetEventsStatus (SBC_InitDriver first, SBC_InitDevice last after reading the status).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>structure which contains configuration of all registers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00108">108</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6c0d44b85038752c6776ecb139f92b08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBC_InitDriver </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>lpspiInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function internally stores LPSPI instance used by the driver. </p>
<p>This function needs to be used before any other function after reset (for example when reading pre-reset or wake-up events).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpspiInstance</td><td>is instance of LPSPI device. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00091">91</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0cb331d43f041923236bf3c203e72339"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> sbc_read_can_others </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsbc__can__conf__t.html">sbc_can_conf_t</a> *const&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01728">1728</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac7668330a4e8b1e32e685ae904a4c37f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_SetCanConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__can__conf__t.html">sbc_can_conf_t</a> *const&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures CAN peripheral behavior. This function configures CAN peripheral behavior. This function configures several registers which configure CAN. It contains CAN control register, Transceiver event capture enable register, CAN data rate selection, ID registers, ID mask registers, Frame control register, Data mask 0 - 7 configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can</td><td>writes CAN peripheral settings to SBC device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00814">814</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac0b26e3c13fa67542548ba8f2c9b04ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_SetFailSafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__sbc__uja116x__driver.html#ga30987b772fc799e9e00bc7355dc6edeb">sbc_fail_safe_lhc_t</a>&#160;</td>
          <td class="paramname"><em>lhc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__sbc__uja116x__driver.html#gad8b22d2a90a70c8494d1b9f3dd7c5cb4">sbc_fail_safe_rcc_t</a> *const&#160;</td>
          <td class="paramname"><em>rcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to Fail-safe control register (0x02). The dedicated LIMP pin can be used to enable so called limp home hardware in the event of a serious ECU failure. Detectable failure conditions include SBC overtemperature events, loss of watchdog service, short-circuits on pins RSTN or V1 and user-initiated or external reset events. The LIMP pin is a battery-robust, active-LOW, open-drain output. The LIMP pin can also be forced LOW by setting bit LHC in the Fail-safe control register. The limp-home function and the reset counter are disabled in Forced Normal mode. The LIMP pin is floating, RCC remains unchanged and bit LHC = 0. RCC -reset counter control. incremented every time the SBC enters Reset mode while FNMC = 0; RCC overflows from 11 to 00; default at power-on is 00. For ignore settings of rcc use NULL pointer or otherwise send pointer to variable. This function is not available on UJA1168 device variants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhc</td><td>Variable for set limp home control. </td></tr>
    <tr><td class="paramname">rcc</td><td>Pointer to rcc. Use null pointer or wrong value for ignore parameter or set value 0x00 to 0x03. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00557">557</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ada5902e0d671d70c4adab5ba63c27cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_SetLock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__sbc__uja116x__driver.html#ga59009e638ca7c7fe656bcf0447a32ee9">sbc_lock_t</a>&#160;</td>
          <td class="paramname"><em>lockMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to Lock control register (0x0A). Sections of the register address area can be write-protected to protect against unintended modifications. This facility only protects locked bits from being modified via the SPI and will not prevent the UJA116xA updating status registers etc. For SPI write disable set lock bit to 1. This is mask for set lock control register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lockMask</td><td>writes Lock control mask for lock or unlock appropriate SBC device bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00737">737</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a39f12391434a44c059e7ad329947620f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_SetMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__sbc__uja116x__driver.html#gaa4630d8955028b5532168f9bf1c7d340">sbc_mode_mc_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to Mode control register. (0x01). </p>
<p>Normal mode is the active operating mode. In this mode, all the hardware on the device is available and can be activated. Voltage regulator V1 is enabled to supply the microcontroller. Standby mode is the first-level power-saving mode of the UJA116xA, offering reduced current consumption. The transceiver is unable to transmit or receive data in Standby mode. The SPI remains enabled and V1 is still active; the watchdog is active (in Timeout mode) if enabled. The behavior of V2/VEXT is determined by the SPI setting. Sleep mode is the second-level power-saving mode of the UJA116xA. The difference between Sleep and Standby modes is that V1 is off in Sleep mode and temperature protection is inactive. Note event status are cleared before device move to sleep mode. At least one wake up event must be enabled before moving to sleep mode otherwise SBC will be reseted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>device mode - Normal, StandBy, Sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00443">443</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac93acdb00340b7657f409edf8d35f036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_SetSystemEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__sys__evnt__t.html">sbc_sys_evnt_t</a> *const&#160;</td>
          <td class="paramname"><em>sysEvnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes System event capture enable register (0x04). This function enables or disables overtemperature warning, SPI failure enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sysEvnt</td><td>system event capture enable register structure which will be written to device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00660">660</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac5ae0462b7d1daf222c2cf2c79e22aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_SetVreg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__regulator__ctr__t.html">sbc_regulator_ctr_t</a> *const&#160;</td>
          <td class="paramname"><em>regulatorCtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures Regulator control registers. </p>
<p>Regulator control (0x10), Supply status (0x1B), Supply event enable(0x1C). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regulatorCtr</td><td>regulator registers structure which will be written to device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00187">187</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="aaec84a1ac7469e4e78ba2ab315e97a6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_SetWakePin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__wake__t.html">sbc_wake_t</a> *const&#160;</td>
          <td class="paramname"><em>wakePin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to WAKE pin event capture enable register (0x4C). Local wake-up is enabled via bits WPRE and WPFE in the WAKE pin event capture enable register. A wake-up event is triggered by a LOW-to-HIGH (ifWPRE = 1) and/or a HIGH-to-LOW (if WPFE = 1) transition on the WAKE pin. This arrangement allows for maximum flexibility when designing a local wake-up circuit. In applications that do not use the local wake-up facility, local wake-up should be disabled and the WAKE pin connected to GND. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakePin</td><td>writes configuration to WAKE pin event capture enable register of SBC device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00945">945</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="acadbfb4ce7b6a4965d4ff3b26654f05a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SBC_SetWatchdog </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__wtdog__ctr__t.html">sbc_wtdog_ctr_t</a> *const&#160;</td>
          <td class="paramname"><em>wtdog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures Watchdog control register (0x00). </p>
<p>This function selects Watchdog mode control, and nominal watchdog period.</p>
<p>The UJA116xA contains a watchdog that supports three operating modes: Window, Timeout and Autonomous. In Window mode (available only in SBC Normal mode), a watchdog trigger event within a defined watchdog window triggers and resets the watchdog timer. In Timeout mode, the watchdog runs continuously and can be triggered and reset at any time within the watchdog period by a watchdog trigger. Watchdog time-out mode can also be used for cyclic wake-up of the microcontroller. In Autonomous mode, the watchdog can be off or autonomously in Timeout mode, depending on the selected SBC mode. Note SBC mode will temporary set to StandBy while WatchDog configuration is changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wtdog</td><td>watchdog registers structure which will be written to device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00293">293</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4c6bfde7e4ab65bea537b569f116c858"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> sbc_write_can_others </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsbc__can__conf__t.html">sbc_can_conf_t</a> *const&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l01677">1677</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a322d7f793591717b1569193f6bf116c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrv__config__t.html">drv_config_t</a> g_drvConfig</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sbc__uja116x__driver_8c_source.html#l00068">68</a> of file <a class="el" href="sbc__uja116x__driver_8c_source.html">sbc_uja116x_driver.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_f382573a88a6eedb79e240e7ead9d11a.html">middleware</a></li><li class="navelem"><a class="el" href="dir_49c56224104f1e32449d81c2ab649ac3.html">sbc</a></li><li class="navelem"><a class="el" href="dir_873408f12f5ab853e069d3c3c1029758.html">sbc_uja116x</a></li><li class="navelem"><a class="el" href="dir_6461e06b80d4daec887265ea0a0358e4.html">source</a></li><li class="navelem"><a class="el" href="sbc__uja116x__driver_8c.html">sbc_uja116x_driver.c</a></li>
    <li class="footer">Generated on Fri Jun 11 2021 08:16:06 for S32 SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
